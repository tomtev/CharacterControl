/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.13 model.glb --shadow --transform 
Files: model.glb [338.55MB] > model-transformed.glb [61.23MB] (82%)
*/

import React, { useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { RigidBody } from "@react-three/rapier";
import * as THREE from "three";

export function Model(props) {
  const { nodes, materials } = useGLTF("/model2-transformed.glb");
  for (const key in nodes) {
    if (nodes[key].material?.map) {
      nodes[key].material['flatShading'] = true
      nodes[key].material.map.magFilter = THREE.NearestFilter;
      nodes[key].material.map.minFilter = THREE.LinearMipMapLinearFilter;
    }

    if (nodes[key].material?.transparent) {
      nodes[key].material.transparent = false;
      nodes[key].material.depthWrite = true;
      nodes[key].material.alphaTest = 0.1 ;
      nodes[key].renderOrder = -1;
      if(nodes[key].material.name === 'Stationary_Water') {
        nodes[key].material.transparent = true;
      }
    }
  }
  return (
    <group {...props} dispose={null}  position={[0, -100, 0]}>
      <RigidBody type="fixed" colliders={"trimesh"}>
        <mesh castShadow receiveShadow geometry={nodes.Stone.geometry} material={materials.Stone} />
        <mesh
          castShadow receiveShadow geometry={nodes.Polished_Andesite.geometry}
          material={materials.Polished_Andesite}
        />
        <mesh
          castShadow receiveShadow geometry={nodes.Oak_Planks.geometry}
          material={materials.Oak_Planks}
        />
        <mesh
          castShadow receiveShadow geometry={nodes.Oak_Sapling.geometry}
          material={materials.Oak_Sapling}
        />
        <mesh
          castShadow receiveShadow geometry={nodes.Stationary_Water.geometry}
          material={materials.Stationary_Water}
        />
        <mesh
          castShadow receiveShadow geometry={nodes.Bubble_Column.geometry}
          material={materials.Bubble_Column}
        />
        <mesh
          castShadow receiveShadow geometry={nodes.Stationary_Lava.geometry}
          material={materials.Stationary_Lava}
        />
        <mesh castShadow receiveShadow geometry={nodes.Glass.geometry} material={materials.Glass} />
        <mesh
          castShadow receiveShadow geometry={nodes.Block_of_Gold.geometry}
          material={materials.Block_of_Gold}
        />
        <mesh castShadow receiveShadow geometry={nodes.Torch.geometry} material={materials.Torch} />
        <mesh
          castShadow receiveShadow geometry={nodes.Block_of_Diamond.geometry}
          material={materials.Block_of_Diamond}
        />
        <mesh
          castShadow receiveShadow geometry={nodes.Iron_Door.geometry}
          material={materials.Iron_Door}
        />
        <mesh castShadow receiveShadow geometry={nodes.Clay.geometry} material={materials.Clay} />
        <mesh
          castShadow receiveShadow geometry={nodes.Lily_Pad.geometry}
          material={materials.Lily_Pad}
        />
        <mesh castShadow receiveShadow geometry={nodes.Hopper.geometry} material={materials.Hopper} />
        <mesh
          castShadow receiveShadow geometry={nodes.Sea_Lantern.geometry}
          material={materials.Sea_Lantern}
        />
        <mesh castShadow receiveShadow geometry={nodes.Lantern.geometry} material={materials.Lantern} />
        <mesh
          castShadow receiveShadow geometry={nodes.Honey_Block.geometry}
          material={materials.Honey_Block}
        />
        <mesh
          castShadow receiveShadow geometry={nodes.Honeycomb_Block.geometry}
          material={materials.Honeycomb_Block}
        />
        <mesh
          castShadow receiveShadow geometry={nodes.Crying_Obsidian.geometry}
          material={materials.Crying_Obsidian}
        />
      </RigidBody>
    </group>
  );
}

useGLTF.preload("/model-transformed.glb");
