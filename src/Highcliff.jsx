/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { Suspense, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { RigidBody } from "@react-three/rapier";
import InstancedObjects from "./InstancedObjects";
import * as THREE from "three";

const getPositionsForObject = (object, vertices = 32) => {
  if (!object) return [];
  

  const positions = object.geometry.attributes.position.array;
  const numVerticesPerObject = vertices;
  const resultPositions = [];

  for (let i = 0; i < positions.length; i += 3 * numVerticesPerObject) {
    let sumX = 0,
      sumY = 0,
      sumZ = 0;

    for (let j = 0; j < numVerticesPerObject; j++) {
      const x = positions[i + 3 * j];
      const y = positions[i + 3 * j + 1];
      const z = positions[i + 3 * j + 2];

      sumX += x;
      sumY += y;
      sumZ += z;
    }

    const centroid = {
      x: sumX / numVerticesPerObject,
      y: sumY / numVerticesPerObject,
      z: sumZ / numVerticesPerObject,
    };

    resultPositions.push(centroid);
  }

  return resultPositions;
};

export function Model(props) {
  const gltf = useGLTF("/model2.glb");
  const dragon = useGLTF("/dragon.glb");

  const noCollision = [
    "Wheat",
    "Grass",
    "Double_Tallgrass",
    "Big_Dripleaf_Stem",
    "Amethyst_Cluster",
    "Tall_Seagrass",
    "Lantern",
    "Peony",
    "Brown_Mushroom",
    "Torch",
    "Allium",
    "Blue_Orchid",
    "Beehive",
    "Sunflower",
    "Seagrass",
    "Lilac",
    "Large_Fern",
    "Azure_Bluet",
    "Lily_Pad",
    "Lantern",
    "Tallgrass",
    "Dripleaf_Stem",
    "Dripleaf",
    "Dandelion",
    "Red_Mushroom",
    "Spruce_Door",
    "Dark_Oak_Door",
    "Oak_Door",
  ];

  const noCollisionObjects = [];

  gltf.scene.traverseVisible((obj) => {
    obj.castShadow = true;
    obj.receiveShadow = true;
    obj.frustumCulled = false;

    if (obj.material?.map) obj.material.map.magFilter = THREE.NearestFilter;
    if (obj.material?.map)
      obj.material.map.minFilter = THREE.LinearMipMapLinearFilter;

    if (obj.material?.transparent) {
      obj.material.depthWrite = true;
      obj.material.alphaTest = 0.1;
      obj.renderOrder = -1;
    }

    if (noCollision.includes(obj.name)) {
      noCollisionObjects.push(gltf.scene.getObjectByName(obj.name));
    }
  });

  const positions = getPositionsForObject(
    gltf.scene.getObjectByName("Grass"),
    16
  );

  noCollision.forEach((object) => {
    gltf.scene.children[0].remove(gltf.scene.getObjectByName(object));
  });
  return (
    <group {...props} dispose={null} position={[0, -20, 0]}>
      <RigidBody type="fixed" colliders={"trimesh"}>
        <primitive object={gltf.scene} />
      </RigidBody>

      <InstancedObjects
        mesh={
          <>
            <boxBufferGeometry args={[1, 1, 1]} />
            <meshStandardMaterial color="pink" opacity={.3} transparent={true} />
          </>
        }
        positions={positions}
      />

      {noCollisionObjects.map((object, i) => (
        <primitive key={i} object={object} />
      ))}
    </group>
  );
}

useGLTF.preload("/model2.glb");
