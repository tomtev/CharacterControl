/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { RigidBody } from "@react-three/rapier";
import * as THREE from "three";

const getPlaceholderObjects = (object, vertices = 32, adjustY = 0) => {
  if (!object) return;
  console.log(object);
  const positions = object.geometry.attributes.position.array;
  const numVerticesPerObject = vertices;
  const objects = [];

  for (let i = 0; i < positions.length; i += 3 * numVerticesPerObject) {
    let minX = Infinity,
      minY = Infinity,
      minZ = Infinity;
    let maxX = -Infinity,
      maxY = -Infinity,
      maxZ = -Infinity;
    let sumX = 0,
      sumY = 0,
      sumZ = 0;

    for (let j = 0; j < numVerticesPerObject; j++) {
      const x = positions[i + 3 * j];
      const y = positions[i + 3 * j + 1];
      const z = positions[i + 3 * j + 2];

      sumX += x;
      sumY += y;
      sumZ += z;

      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      minZ = Math.min(minZ, z);

      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
      maxZ = Math.max(maxZ, z);
    }

    const centroid = {
      x: sumX / numVerticesPerObject,
      y: sumY / numVerticesPerObject,
      z: sumZ / numVerticesPerObject,
    };

    const size = {
      x: maxX - minX,
      y: maxY - minY,
      z: maxZ - minZ,
    };

    objects.push(
      <mesh
        key={
          object.name + "_" + centroid.x + "_" + centroid.y + "_" + centroid.z
        }
        position={[centroid.x, centroid.y + adjustY, centroid.z]}
      >
        <boxGeometry args={[size.x, size.y, size.z]} />
        <meshBasicMaterial color="blue" transparent={true} opacity={0.5} />
      </mesh>
    );
  }
  return objects;
};

export function Model(props) {
  const gltf = useGLTF("/model2.glb");
  const dragon = useGLTF("/dragon.glb");

  const noCollision = [
    "Wheat",
    "Grass",
    "Double_Tallgrass",
    "Big_Dripleaf_Stem",
    "Amethyst_Cluster",
    "Tall_Seagrass",
    "Lantern",
    "Peony",
    "Brown_Mushroom",
    "Torch",
    "Allium",
    "Blue_Orchid",
    "Beehive",
    "Sunflower",
    "Seagrass",
    "Lilac",
    "Large_Fern",
    "Azure_Bluet",
    "Lily_Pad",
    "Lantern",
    "Tallgrass",
    "Dripleaf_Stem",
    "Dripleaf",
    "Dandelion",
    "Red_Mushroom",
    "Spruce_Door",
    "Dark_Oak_Door",
    "Oak_Door",
  ];

  const noCollisionObjects = [];

  const Oak_Door_2 = getPlaceholderObjects(
    gltf.scene.getObjectByName("Oak_Door_2"),
    32,
    0.25
  );

  gltf.scene.traverseVisible((obj) => {
    obj.castShadow = true;
    obj.receiveShadow = true;
    obj.frustumCulled = false;

    if (obj.material?.map) obj.material.map.magFilter = THREE.NearestFilter;
    if (obj.material?.map)
      obj.material.map.minFilter = THREE.LinearMipMapLinearFilter;

    if (obj.material?.transparent) {
      obj.material.depthWrite = true;
      obj.material.alphaTest = 0.1;
      obj.renderOrder = -1;
    }

    if (noCollision.includes(obj.name)) {
      noCollisionObjects.push(gltf.scene.getObjectByName(obj.name));
    }
  });

  noCollision.forEach((object) => {
    gltf.scene.children[0].remove(gltf.scene.getObjectByName(object));
  });
  return (
    <group {...props} dispose={null} position={[0, -20, 0]}>
      <RigidBody type="fixed" colliders={"trimesh"}>
        <primitive object={gltf.scene} />
      </RigidBody>
      <mesh
        position={[183.64752197265625, 6.499988317489624, -143.54598236083984]}
        scale={[0.906982421875, 0.9999442100524902, 0.9059295654296875]}
      >
        <boxGeometry args={[1, 1, 1]} />
        <meshBasicMaterial color="blue" transparent={true} opacity={1} />
      </mesh>
      {noCollisionObjects.map((object, i) => (
        <primitive key={i} object={object} />
      ))}
      {/* Placeholder */}
      {Oak_Door_2}
    </group>
  );
}

useGLTF.preload("/model2.glb");
